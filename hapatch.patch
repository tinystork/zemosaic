diff --git a/zemosaic_worker.py b/zemosaic_worker.py
index fe06e38fc6ba346638f29a36ae682cf166df3e6a..988ac51489d489a2d4c2027004fcf0fe5ce14e72 100644
--- a/zemosaic_worker.py
+++ b/zemosaic_worker.py
@@ -13573,51 +13573,57 @@ def assemble_final_mosaic_reproject_coadd(
                 continue
             applied_channels = 0
             for c in range(min(data_arr.shape[-1], gains.shape[0])):
                 gain_val = float(gains[c])
                 if not math.isfinite(gain_val):
                     continue
                 np.multiply(data_arr[..., c], gain_val, out=data_arr[..., c], casting="unsafe")
                 applied_channels += 1
             if applied_channels > 0:
                 try:
                     pcb_msg = "[ExistingMT] applied anchor gain"
                     logger.info(
                         "existing_master_tiles_mode: anchor gain applied to tile %d (overlap=%d, gains=%s)",
                         idx_entry,
                         overlap_count,
                         ", ".join(f"{g:.3f}" for g in gains.tolist()),
                     )
                     _pcb(
                         pcb_msg,
                         prog=None,
                         lvl="INFO_DETAIL",
                     )
                 except Exception:
                     pass
 
-    _best_effort_anchor_photometry()
+    try:
+        _best_effort_anchor_photometry()
+    except Exception as anchor_exc:
+        logger.info(
+            "existing_master_tiles_mode: best-effort anchor failed; continuing without anchor",
+            exc_info=logger.isEnabledFor(logging.DEBUG),
+        )
 
     # Optional inter-tile photometric (gain/offset) calibration
     pending_affine_list, nontrivial_affine = _sanitize_affine_corrections(
         tile_affine_corrections,
         len(effective_tiles),
     )
 
     if (
         pending_affine_list is None
         and intertile_photometric_match
         and len(effective_tiles) >= 2
     ):
         tile_sources = []
         for entry in effective_tiles:
             mask = None
             if isinstance(entry, dict):
                 mask = entry.get("alpha_weight2d")
                 if mask is None:
                     mask = entry.get("coverage_mask")
             tile_sources.append(
                 _TileAffineSource(
                     path=entry.get("path"),
                     wcs=entry.get("wcs"),
                     data=entry.get("data"),
                     mask=mask,
