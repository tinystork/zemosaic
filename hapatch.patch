diff --git a/agent.md b/agent.md
index 06743c0f8dbd5ce41f4c7a26e16778f9ecfc2eab..3a88da75942ef497fb15f0e8131d92351456e58f 100644
--- a/agent.md
+++ b/agent.md
@@ -7,76 +7,75 @@ Le log indique :
 - phase6: alpha_union received -> alpha_final propagé
 - puis: nanized X pixels where coverage/alpha == 0
 
 Hypothèse : dans ce mode seulement, l’alpha reprojeté (alpha_union) peut être incohérent (ex: 0 dans des zones couvertes), et comme on nanize en fonction de l’alpha, on “perce” un trou artificiel.
 
 ## Objectif (Option B)
 Quand on est en mode "use_existing_master_tiles", dériver l’ALPHA FINAL à partir du coverage final :
 - alpha_final[u,v] = 255 si coverage[u,v] > 0
 - alpha_final[u,v] = 0 sinon
 
 Et ne pas laisser un alpha_union incohérent dégrader le rendu final.
 
 ## Contraintes
 - Patch chirurgical.
 - Ne pas changer le comportement normal hors de ce mode.
 - Ne pas refactorer l’architecture.
 - Zéro impact sur batch size, GPU/CPU, etc.
 
 ## Fichiers à modifier
 - `zemosaic_worker.py` uniquement (idéalement)
   - `run_hierarchical_mosaic_classic_legacy(...)`
   - `assemble_final_mosaic_reproject_coadd(...)`
 
 ## Plan d’implémentation
 
-### 1) Propager un bool "existing_master_tiles_mode" vers l’assembleur final
-- Ajouter un paramètre optionnel à `assemble_final_mosaic_reproject_coadd` :
-  - `existing_master_tiles_mode: bool = False`
-- Dans `run_hierarchical_mosaic_classic_legacy`, lors de l’appel à `assemble_final_mosaic_reproject_coadd`, passer :
-  - `existing_master_tiles_mode=use_existing_master_tiles_config` (ou l’équivalent déjà présent)
+- [x] Propager un bool "existing_master_tiles_mode" vers l’assembleur final
+  - Ajouter un paramètre optionnel à `assemble_final_mosaic_reproject_coadd` :
+    - `existing_master_tiles_mode: bool = False`
+  - Dans `run_hierarchical_mosaic_classic_legacy`, lors de l’appel à `assemble_final_mosaic_reproject_coadd`, passer :
+    - `existing_master_tiles_mode=use_existing_master_tiles_config` (ou l’équivalent déjà présent)
 
 ⚠️ Important : garder une valeur par défaut pour ne rien casser ailleurs.
 
-### 2) Rebuild alpha_final depuis coverage en mode existing master tiles
-Dans `assemble_final_mosaic_reproject_coadd`, à l’endroit où `alpha_union` est converti en `alpha_final` (phase6), insérer juste après l’obtention de `alpha_final` et avant toute logique “coverage/alpha == 0” :
-
-Pseudo-code :
-
-```python
-if existing_master_tiles_mode and coverage is not None:
-    cov_mask = coverage > 0
-    if alpha_final is None:
-        alpha_final = (cov_mask.astype(np.uint8) * 255)
-        log("alpha_from_coverage: alpha_final was None -> rebuilt")
-    else:
-        # détecter mismatch : coverage>0 mais alpha==0
-        alpha0 = (alpha_final == 0)
-        mismatch = np.count_nonzero(cov_mask & alpha0)
-        if mismatch > 0:
-            total_cov = np.count_nonzero(cov_mask)
-            pct = (100.0 * mismatch / max(1, total_cov))
-            log(f"alpha_from_coverage: overriding alpha_final (mismatch={mismatch} px, {pct:.2f}% of covered)")
+- [x] Rebuild alpha_final depuis coverage en mode existing master tiles
+  - Dans `assemble_final_mosaic_reproject_coadd`, à l’endroit où `alpha_union` est converti en `alpha_final` (phase6), insérer juste après l’obtention de `alpha_final` et avant toute logique “coverage/alpha == 0” :
+
+    Pseudo-code :
+
+    ```python
+    if existing_master_tiles_mode and coverage is not None:
+        cov_mask = coverage > 0
+        if alpha_final is None:
             alpha_final = (cov_mask.astype(np.uint8) * 255)
-````
+            log("alpha_from_coverage: alpha_final was None -> rebuilt")
+        else:
+            # détecter mismatch : coverage>0 mais alpha==0
+            alpha0 = (alpha_final == 0)
+            mismatch = np.count_nonzero(cov_mask & alpha0)
+            if mismatch > 0:
+                total_cov = np.count_nonzero(cov_mask)
+                pct = (100.0 * mismatch / max(1, total_cov))
+                log(f"alpha_from_coverage: overriding alpha_final (mismatch={mismatch} px, {pct:.2f}% of covered)")
+                alpha_final = (cov_mask.astype(np.uint8) * 255)
+    ````
 
-* Forcer dtype `uint8`, shape identique au coverage.
-* Conserver `alpha_union` tel quel pour les autres modes.
+    * Forcer dtype `uint8`, shape identique au coverage.
+    * Conserver `alpha_union` tel quel pour les autres modes.
 
-### 3) Logging / Observabilité
+- [x] Logging / Observabilité
 
-Ajouter un log INFO (et si tu veux un callback GUI type `[INFO] ...`) quand on override :
+  - Ajouter un log INFO (et si tu veux un callback GUI type `[INFO] ...`) quand on override :
 
-* nb pixels mismatch
-* % des pixels couverts impactés
-* mention claire “existing_master_tiles_mode”
+  * nb pixels mismatch
+  * % des pixels couverts impactés
+  * mention claire “existing_master_tiles_mode”
 
-### 4) Critères d’acceptation
+- [ ] Critères d’acceptation
 
-* En mode existing master tiles, plus de trou central si le coverage indique une couverture.
-* Les stats “nanized pixels where coverage/alpha == 0” ne doivent plus nanizer des pixels `coverage>0` à cause de l’alpha.
-* Hors de ce mode : comportement inchangé.
+  * En mode existing master tiles, plus de trou central si le coverage indique une couverture.
+  * Les stats “nanized pixels where coverage/alpha == 0” ne doivent plus nanizer des pixels `coverage>0` à cause de l’alpha.
+  * Hors de ce mode : comportement inchangé.
 
 ## Notes
 
 * Ce fix est volontairement conservateur : en mode existing master tiles, on privilégie la vérité “coverage” (résultat de l’assemblage) plutôt qu’un alpha potentiellement corrompu/inversé venant des fichiers en entrée.
-
diff --git a/followup.md b/followup.md
index e6f3901291814dc531a81af11e5704ce73641256..6f2c6e470315512fdad9c74723cb7717b9430610 100644
--- a/followup.md
+++ b/followup.md
@@ -1,32 +1,31 @@
 # followup.md — Vérifs & Validation (alpha_from_coverage en mode existing master tiles)
 
 ## 1) Repro / Test manuel rapide (cas M31)
-- Utiliser exactement le dataset + config qui déclenche le problème (use_existing_master_tiles=true, quality_crop=false).
-- Lancer un run.
-- Attendus :
+- [ ] Utiliser exactement le dataset + config qui déclenche le problème (use_existing_master_tiles=true, quality_crop=false).
+- [ ] Lancer un run.
+- [ ] Attendus :
   - La preview PNG n’a plus de “gros trou” central.
   - Le FITS final contient une extension ALPHA (si c’était déjà le cas), mais cette ALPHA doit maintenant correspondre au coverage.
 
 ## 2) Check quantitatif simple (log)
-Attendre un log du type :
-- `alpha_from_coverage: overriding alpha_final (mismatch=..., ..% of covered)`
-ou
-- `alpha_from_coverage: alpha_final was None -> rebuilt`
-
-Et vérifier qu’il n’y a plus de “nanized pixels” induits par un alpha incohérent.
+- [ ] Attendre un log du type :
+  - `alpha_from_coverage: overriding alpha_final (mismatch=..., ..% of covered)`
+  - ou
+  - `alpha_from_coverage: alpha_final was None -> rebuilt`
+- [ ] Et vérifier qu’il n’y a plus de “nanized pixels” induits par un alpha incohérent.
 
 ## 3) Sanity check : cohérence alpha vs coverage
-Ajouter temporairement (ou via debug local) un petit calcul :
-- `mismatch_after = count((coverage>0) & (alpha_final==0))`
-Attendu : `mismatch_after == 0`
+- [ ] Ajouter temporairement (ou via debug local) un petit calcul :
+  - `mismatch_after = count((coverage>0) & (alpha_final==0))`
+- [ ] Attendu : `mismatch_after == 0`
 
 ## 4) Non-régression (mode normal)
-- Lancer un run classique (sans existing master tiles).
-- Vérifier :
+- [ ] Lancer un run classique (sans existing master tiles).
+- [ ] Vérifier :
   - pas de changement de comportement,
   - alpha_union continue d’être propagé tel qu’avant,
   - pas de nouveaux logs alpha_from_coverage.
 
 ## 5) Nettoyage
-- Garder les logs INFO (utiles).
-- Ne pas ajouter de dépendances.
+- [ ] Garder les logs INFO (utiles).
+- [ ] Ne pas ajouter de dépendances.
diff --git a/zemosaic_worker.py b/zemosaic_worker.py
index 8c81728db0544401c5ac2f19541248a86d7f666d..fd88dbda9b496056c8547df026449ebf24a5b5a6 100644
--- a/zemosaic_worker.py
+++ b/zemosaic_worker.py
@@ -8036,50 +8036,51 @@ def _run_shared_phase45_phase5_pipeline(
                 match_bg=True,
                 apply_crop=apply_crop_for_assembly,
                 crop_percent=master_tile_crop_percent_config,
                 use_gpu=effective_use_gpu,
                 use_memmap=bool(coadd_use_memmap_config),
                 memmap_dir=(coadd_memmap_dir_config or output_folder),
                 cleanup_memmap=False,
                 base_progress_phase5=base_progress_phase5,
                 progress_weight_phase5=progress_weight_phase5,
                 start_time_total_run=start_time_total,
                 intertile_photometric_match=intertile_match_flag,
                 intertile_preview_size=int(intertile_preview_size_config),
                 intertile_overlap_min=float(intertile_overlap_min_config),
                 intertile_sky_percentile=intertile_sky_percentile_tuple,
                 intertile_robust_clip_sigma=float(intertile_robust_clip_sigma_config),
                 intertile_global_recenter=bool(intertile_global_recenter_config),
                 intertile_recenter_clip=intertile_recenter_clip_tuple,
                 use_auto_intertile=bool(use_auto_intertile_config),
                 collect_tile_data=collected_tiles_for_second_pass,
                 global_anchor_shift=global_anchor_shift,
                 phase45_enabled=phase45_active_flag,
                 parallel_plan=parallel_plan_phase5,
                 enable_tile_weighting=tile_weighting_enabled_flag,
                 tile_weight_mode=tile_weight_mode,
                 stats_callback=_emit_phase5_stats,
+                existing_master_tiles_mode=bool(use_existing_master_tiles_mode),
             )
         except Exception as exc:
             logger.exception("Reproject+Coadd assembly failed", exc_info=True)
             final_mosaic_data_HWC = None
         log_key_phase5_failed = "run_error_phase5_assembly_failed_reproject_coadd"
         log_key_phase5_finished = "run_info_phase5_finished_reproject_coadd"
 
     if final_mosaic_data_HWC is None:
         pcb(
             log_key_phase5_failed or "run_error_phase5_assembly_failed_unknown",
             prog=base_progress_phase5 + progress_weight_phase5,
             lvl="ERROR",
         )
         _emit_phase5_stats(0, tiles_total_phase5, force=True, stage="failed")
         return master_tiles, None, None, None, None, base_progress_phase5 + progress_weight_phase5
 
     current_global_progress = base_progress_phase5 + progress_weight_phase5
 
     if USE_INCREMENTAL_ASSEMBLY:
         def _load_tiles_for_two_pass_phase5():
             return _load_master_tiles_for_two_pass(
                 valid_master_tiles_for_assembly,
                 apply_crop=apply_crop_for_assembly,
                 crop_percent=master_tile_crop_percent_config,
                 logger=logger,
@@ -12745,50 +12746,51 @@ def assemble_final_mosaic_reproject_coadd(
     cleanup_memmap: bool = True,
     assembly_process_workers: int = 0,
     re_solve_cropped_tiles: bool = False,
     solver_settings: dict | None = None,
     solver_instance=None,
     use_gpu: bool = False,
     base_progress_phase5: float | None = None,
     progress_weight_phase5: float | None = None,
     start_time_total_run: float | None = None,
     intertile_photometric_match: bool = False,
     intertile_preview_size: int = 512,
     intertile_overlap_min: float = 0.05,
     intertile_sky_percentile: tuple[float, float] | list[float] = (30.0, 70.0),
     intertile_robust_clip_sigma: float = 2.5,
     intertile_global_recenter: bool = True,
     intertile_recenter_clip: tuple[float, float] | list[float] | None = (0.85, 1.18),
     use_auto_intertile: bool = False,
     collect_tile_data: list | None = None,
     tile_affine_corrections: list[tuple[float, float]] | None = None,
     global_anchor_shift: tuple[float, float] | None = None,
     phase45_enabled: bool = False,
     parallel_plan: ParallelPlan | None = None,
     enable_tile_weighting: bool = False,
     tile_weight_mode: str | None = None,
     stats_callback: Callable[[int, int, bool], None] | None = None,
+    existing_master_tiles_mode: bool = False,
 ):
     """Assemble les master tiles en utilisant ``reproject_and_coadd``."""
     _pcb = lambda msg_key, prog=None, lvl="INFO_DETAIL", **kwargs: _log_and_callback(
         msg_key, prog, lvl, callback=progress_callback, **kwargs
     )
 
     _log_memory_usage(progress_callback, "Début assemble_final_mosaic_reproject_coadd")
     _pcb(
         f"ASM_REPROJ_COADD: Options de rognage - Appliquer: {apply_crop}, Pourcentage: {crop_percent if apply_crop else 'N/A'}",
         lvl="DEBUG_DETAIL",
     )
 
     explicit_workers = None
     try:
         if assembly_process_workers and int(assembly_process_workers) > 0:
             explicit_workers = int(assembly_process_workers)
             assembly_process_workers = explicit_workers
     except Exception:
         explicit_workers = None
 
     start_time_phase = time.monotonic()
     plan_rows_cpu_hint: int | None = None
     plan_rows_gpu_hint: int | None = None
     plan_chunk_cpu_hint: int | None = None
     plan_chunk_gpu_hint: int | None = None
@@ -13941,50 +13943,92 @@ def assemble_final_mosaic_reproject_coadd(
         lvl="INFO",
         shape=mosaic_data.shape if mosaic_data is not None else "N/A",
     )
 
     if mosaic_data is not None:
         if mosaic_data.ndim != 3:
             raise ValueError(f"Expected final mosaic in HWC order, got {mosaic_data.shape}")
         logger.debug("Mosaic shape (HWC): %s", mosaic_data.shape)
         if isinstance(coverage, np.ndarray) and logger.isEnabledFor(logging.DEBUG):
             mask = coverage > 0
             if np.any(mask):
                 stats = []
                 for c in range(mosaic_data.shape[-1]):
                     vals = mosaic_data[..., c][mask]
                     if vals.size:
                         stats.append((float(np.mean(vals)), float(np.std(vals))))
                     else:
                         stats.append((float("nan"), float("nan")))
                 logger.debug(
                     "Reproject overlap stats (mean/std per channel): %s",
                     stats,
                 )
 
     if isinstance(coverage, np.ndarray):
         coverage = np.where(np.isfinite(coverage), coverage, 0.0).astype(np.float32, copy=False)
+    if isinstance(coverage, np.ndarray) and existing_master_tiles_mode:
+        try:
+            cov_mask_bool = np.asarray(coverage, dtype=np.float32, order="C")
+            cov_mask_bool = np.nan_to_num(cov_mask_bool, nan=0.0, posinf=0.0, neginf=0.0)
+            cov_mask_bool = cov_mask_bool > 0.0
+            alpha_target_shape = cov_mask_bool.shape
+            override_message = None
+            if alpha_final is None:
+                alpha_final = np.ascontiguousarray(cov_mask_bool.astype(np.uint8) * 255)
+                override_message = "alpha_final was None -> rebuilt"
+            else:
+                alpha_arr = np.asarray(alpha_final)
+                if alpha_arr.ndim == 3 and alpha_arr.shape[-1] == 1:
+                    alpha_arr = alpha_arr[..., 0]
+                alpha_arr = np.squeeze(alpha_arr)
+                if alpha_arr.shape != alpha_target_shape:
+                    override_message = (
+                        f"overriding alpha_final due to shape mismatch (alpha={alpha_arr.shape}, coverage={alpha_target_shape})"
+                    )
+                    alpha_final = np.ascontiguousarray(cov_mask_bool.astype(np.uint8) * 255)
+                else:
+                    alpha_zero = alpha_arr == 0
+                    mismatch = int(np.count_nonzero(cov_mask_bool & alpha_zero))
+                    if mismatch > 0:
+                        total_cov = int(np.count_nonzero(cov_mask_bool))
+                        pct = (100.0 * mismatch) / max(1, total_cov)
+                        override_message = f"overriding alpha_final (mismatch={mismatch} px, {pct:.2f}% of covered)"
+                        alpha_final = np.ascontiguousarray(cov_mask_bool.astype(np.uint8) * 255)
+            if alpha_final is not None and alpha_final.shape == alpha_target_shape:
+                mismatch_after = int(np.count_nonzero(cov_mask_bool & (np.asarray(alpha_final) == 0)))
+                if mismatch_after != 0 and logger.isEnabledFor(logging.DEBUG):
+                    logger.debug(
+                        "alpha_from_coverage: mismatch_after=%d (existing_master_tiles_mode)",
+                        mismatch_after,
+                    )
+            if override_message:
+                logger.info(
+                    "alpha_from_coverage (existing_master_tiles_mode): %s",
+                    override_message,
+                )
+        except Exception as exc_alpha_cov:
+            logger.debug("alpha_from_coverage: override skipped due to error: %s", exc_alpha_cov)
     alpha_zero_mask = None
     if isinstance(coverage, np.ndarray) and alpha_final is not None:
         try:
             alpha_arr = np.asarray(alpha_final)
             if alpha_arr.ndim == 3 and alpha_arr.shape[-1] == 1:
                 alpha_arr = alpha_arr[..., 0]
             alpha_arr = np.squeeze(alpha_arr)
             if alpha_arr.ndim >= 2 and alpha_arr.shape[:2] == coverage.shape:
                 alpha_zero_mask = alpha_arr <= 0
                 if np.any(alpha_zero_mask):
                     coverage = np.where(alpha_zero_mask, 0.0, coverage).astype(np.float32, copy=False)
         except Exception:
             alpha_zero_mask = None
     if mosaic_data is not None and coverage is not None:
         mosaic_data = np.asarray(mosaic_data, dtype=np.float32, copy=False)
         mosaic_data[~np.isfinite(mosaic_data)] = np.nan
         nanized_mask = coverage <= 0
         if alpha_zero_mask is not None:
             nanized_mask = np.logical_or(nanized_mask, alpha_zero_mask)
         elif alpha_final is not None and alpha_final.shape[:2] == coverage.shape:
             nanized_mask = np.logical_or(nanized_mask, alpha_final == 0)
         nanized_pixels = int(np.count_nonzero(nanized_mask))
         mosaic_data = _nanize_by_coverage(mosaic_data, coverage, alpha_u8=alpha_final)
         if nanized_pixels > 0:
             logger.info(
