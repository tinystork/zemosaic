diff --git a/zemosaic_worker.py b/zemosaic_worker.py
index 549b41511c33d35bc2b6d07d0dc258acd13c51a9..5e22477fb19a2b13f4a8e4fb1b988cc189b96662 100644
--- a/zemosaic_worker.py
+++ b/zemosaic_worker.py
@@ -13775,55 +13775,70 @@ def assemble_final_mosaic_reproject_coadd(
         lvl="INFO",
         shape=mosaic_data.shape if mosaic_data is not None else "N/A",
     )
 
     if mosaic_data is not None:
         if mosaic_data.ndim != 3:
             raise ValueError(f"Expected final mosaic in HWC order, got {mosaic_data.shape}")
         logger.debug("Mosaic shape (HWC): %s", mosaic_data.shape)
         if isinstance(coverage, np.ndarray) and logger.isEnabledFor(logging.DEBUG):
             mask = coverage > 0
             if np.any(mask):
                 stats = []
                 for c in range(mosaic_data.shape[-1]):
                     vals = mosaic_data[..., c][mask]
                     if vals.size:
                         stats.append((float(np.mean(vals)), float(np.std(vals))))
                     else:
                         stats.append((float("nan"), float("nan")))
                 logger.debug(
                     "Reproject overlap stats (mean/std per channel): %s",
                     stats,
                 )
 
     if isinstance(coverage, np.ndarray):
         coverage = np.where(np.isfinite(coverage), coverage, 0.0).astype(np.float32, copy=False)
+    alpha_zero_mask = None
+    if isinstance(coverage, np.ndarray) and alpha_final is not None:
+        try:
+            alpha_arr = np.asarray(alpha_final)
+            if alpha_arr.ndim == 3 and alpha_arr.shape[-1] == 1:
+                alpha_arr = alpha_arr[..., 0]
+            alpha_arr = np.squeeze(alpha_arr)
+            if alpha_arr.ndim >= 2 and alpha_arr.shape[:2] == coverage.shape:
+                alpha_zero_mask = alpha_arr <= 0
+                if np.any(alpha_zero_mask):
+                    coverage = np.where(alpha_zero_mask, 0.0, coverage).astype(np.float32, copy=False)
+        except Exception:
+            alpha_zero_mask = None
     if mosaic_data is not None and coverage is not None:
         mosaic_data = np.asarray(mosaic_data, dtype=np.float32, copy=False)
         mosaic_data[~np.isfinite(mosaic_data)] = np.nan
         nanized_mask = coverage <= 0
-        if alpha_final is not None and alpha_final.shape[:2] == coverage.shape:
+        if alpha_zero_mask is not None:
+            nanized_mask = np.logical_or(nanized_mask, alpha_zero_mask)
+        elif alpha_final is not None and alpha_final.shape[:2] == coverage.shape:
             nanized_mask = np.logical_or(nanized_mask, alpha_final == 0)
         nanized_pixels = int(np.count_nonzero(nanized_mask))
         mosaic_data = _nanize_by_coverage(mosaic_data, coverage, alpha_u8=alpha_final)
         if nanized_pixels > 0:
             logger.info(
                 "assemble_reproject_coadd: nanized %d pixels where coverage/alpha == 0",
                 nanized_pixels,
             )
 
     _update_eta(n_channels)
 
     return (
         mosaic_data.astype(np.float32),
         coverage.astype(np.float32),
         alpha_final,
     )
 
 def _load_master_tiles_for_two_pass(
     master_tile_fits_with_wcs_list: list,
     *,
     apply_crop: bool,
     crop_percent: float,
     logger=None,
 ):
     """Load master tiles from disk for the coverage renormalization pass."""
