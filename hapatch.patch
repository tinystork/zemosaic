diff --git a/agent.md b/agent.md
index 0d608c478edc64a02f8d071491dcd55153318c7a..45f66607005b31a73e2718e57070d574e7f3c0a1 100644
--- a/agent.md
+++ b/agent.md
@@ -1,38 +1,47 @@
 # agent.md
 
 ## Goal
 Ensure Phase 5 GPU "reproject & coadd" properly applies per-tile scalar weighting (tile_weight, e.g. N_FRAMES=502 vs 5 vs 3)
 in addition to per-pixel alpha masks. Without this, shallow/noisy master tiles contribute almost equally and can dominate
 the mosaic.
 
 Target behavior:
 - Effective weights for coadd must be: effective_weight2d = alpha_weight2d * tile_weight
 - Output coverage/weight_sum must reflect weighted sums (max can reach ~sum(tile_weight) in overlaps).
 
 No refactor: surgical patch.
 
+## Progress
+- [x] Step 1) Identify the Phase 5 weight construction point
+- [x] Step 2) Apply tile_weight to GPU input_weights (alpha_weight2d*tile_weight)
+- [x] Step 3) Keep alpha union semantics unchanged
+- [x] Step 4) Make GPU and CPU Phase 5 behavior consistent
+- [x] Step 5) Update debug logging to confirm behavior
+- [ ] Step 6) Two-pass compatibility
+- [ ] Step 7) Validation / Tests
+
 ## Scope (minimal)
 Modify ONLY:
 - zemosaic_worker.py
 - (optional) zemosaic_utils.py or GPU helper module only if strictly required by current architecture
 
 Do not change GUI, settings schema, or unrelated phases.
 
 ## Background
 Logs show:
 - Tile-weighting enabled (min=5 max=502) is computed.
 - But Phase 5 logs input_weights sample source=alpha_weight2d with max=1.0, indicating tile_weight is not applied to GPU coadd.
 
 CPU path already multiplies input_weights by tile_weight; GPU path must mirror it.
 
 ## Plan
 
 ### 1) Identify the Phase 5 weight construction point
 In `assemble_final_mosaic_reproject_coadd()` locate the block that defines `input_weights` for each channel/tile.
 It currently sets `input_weights` from per-pixel alpha (e.g. alpha_weight2d).
 
 Also locate the scalar per-tile weight (tile_weight) used by tile-weighting mode (N_FRAMES etc).
 This likely exists as `tile_weight`, `tile_weights[idx]`, or `tile_entry["tile_weight"]`.
 
 ### 2) Apply tile_weight to GPU input_weights (the core fix)
 Right after `alpha_weight2d` / `input_weights` is prepared for a tile, and BEFORE calling any GPU reproject/coadd kernel:
diff --git a/followup.md b/followup.md
index a4eff94970b6ed36a9647586188e3eb63fbd8644..de1239865bffacb69998175bf16d80e73622e7fe 100644
--- a/followup.md
+++ b/followup.md
@@ -1,27 +1,32 @@
 # followup.md
 
+## Progress
+- [x] Step 1) Anchor selection
+- [x] Step 2) Apply tile_weight to GPU Phase 5 weights
+- [ ] Quick sanity run (CPU vs GPU)
+
 ## How to apply step 2 (practical)
 You already did step 1 (anchor selection). Step 2 is independent and should be applied in Phase 5 only:
 
 1) Find where Phase 5 prepares `alpha_weight2d` / `input_weights` (the log shows it currently labels them as `source=alpha_weight2d`).
 2) Find the scalar `tile_weight` computed from N_FRAMES (or equivalent).
 3) Multiply the weights used for coadd by `tile_weight`:
    - effective weights = alpha_weight2d * tile_weight
 4) Make sure this multiplication happens ONCE per tile (avoid triple-multiplying if weight arrays are shared across channels).
 5) Keep alpha_union unchanged.
 
 ## What to look for in logs (must-have)
 - Before patch (current):
   `[Phase5] input_weights sample ... source=alpha_weight2d ... max=1.0000`
 - After patch:
   `[Phase5] input_weights sample ... source=alpha_weight2d*tile_weight ... maxâ‰ˆ502 (or your tile weight)`
 
 Also look for a single line per tile:
 `tile_weight applied ... tw=...`
 
 ## Quick sanity run
 Run the same dataset twice:
 - GPU Phase 5 OFF
 - GPU Phase 5 ON
 
 Compare:
diff --git a/zemosaic_worker.py b/zemosaic_worker.py
index 1fe3ee7ab8b42d5c3bcd9b4bffc11c0917fca947..8e3d1942de94f49b98d6d681a784ce0f4e37d213 100644
--- a/zemosaic_worker.py
+++ b/zemosaic_worker.py
@@ -14024,140 +14024,180 @@ def assemble_final_mosaic_reproject_coadd(
             coverage_memmap = np.memmap(str(coverage_mm_path), dtype=np.float32, mode='w+', shape=(h, w))
             _pcb(
                 "assemble_debug_memmap_paths",
                 prog=None,
                 lvl="DEBUG_DETAIL",
                 mosaic_path=str(mosaic_mm_path),
                 coverage_path=str(coverage_mm_path),
             )
         except Exception as e_mm:
             mosaic_memmap = None
             coverage_memmap = None
             _pcb("assemble_warn_memmap_create_failed", prog=None, lvl="WARN", error=str(e_mm))
     try:
         total_steps = n_channels
         start_time_loop = time.time()
         last_time = start_time_loop
         step_times = []
         if use_gpu:
             try:
                 _pcb(
                     f"ASM_REPROJ_COADD: GPU background match enabled (preview={reproj_kwargs.get('bg_preview_size','N/A')}, sky={reproj_kwargs.get('intertile_sky_percentile','N/A')}, clip={reproj_kwargs.get('intertile_robust_clip_sigma','N/A')})",
                     lvl="DEBUG_DETAIL",
                 )
             except Exception:
                 pass
+        weight_array_scaled_ids: set[int] = set()
+        tile_weight_log_ids: set[str] = set()
+        weights_embedded_with_tile = False
         for ch in range(n_channels):
             valid_entries: list[dict[str, Any]] = []
             for entry in effective_tiles:
                 arr = entry.get("data") if isinstance(entry, dict) else None
                 if arr is None:
                     continue
                 if arr.ndim != 3:
                     raise ValueError(
                         f"Master tile data must be HWC before channel slicing, got {arr.shape}"
                     )
                 if ch >= arr.shape[-1]:
                     raise ValueError(
                         f"Channel index {ch} out of bounds for tile shape {arr.shape}"
                     )
                 valid_entries.append(entry)
 
             data_list = []
             wcs_list = []
             input_weights_list = []
             weight_debug_logged = False
-            for entry in valid_entries:
+            for idx_entry, entry in enumerate(valid_entries):
                 entry_data = entry.get("data")
                 data_plane = entry_data[..., ch]
                 data_list.append(data_plane)
                 wcs_list.append(entry.get("wcs"))
-                weight_source = "ones"
+                weight_source_base = "ones"
                 weight2d = entry.get("alpha_weight2d") if isinstance(entry, dict) else None
                 if weight2d is not None:
-                    weight_source = "alpha_weight2d"
+                    weight_source_base = "alpha_weight2d"
                 else:
                     coverage_mask = entry.get("coverage_mask") if isinstance(entry, dict) else None
                     if coverage_mask is not None:
                         try:
                             weight_candidate = np.asarray(coverage_mask, dtype=np.float32, order="C", copy=False)
                             if weight_candidate.shape == data_plane.shape:
                                 weight2d = np.clip(
                                     np.nan_to_num(weight_candidate, nan=0.0, posinf=0.0, neginf=0.0),
                                     0.0,
                                     1.0,
                                 )
-                                weight_source = "coverage_mask"
+                                weight_source_base = "coverage_mask"
                         except Exception:
                             weight2d = None
                     if weight2d is None:
                         weight2d = np.ones_like(data_plane, dtype=np.float32)
+                weight_source = weight_source_base
+                if tile_weighting_applied:
+                    try:
+                        tw_raw = entry.get("tile_weight", 1.0) if isinstance(entry, dict) else 1.0
+                        tw_value = float(tw_raw)
+                    except Exception:
+                        tw_value = 1.0
+                    if not math.isfinite(tw_value) or tw_value <= 0.0:
+                        tw_value = 1.0
+                    weights_embedded_with_tile = True
+                    if isinstance(weight2d, np.ndarray):
+                        weight_arr = np.asarray(weight2d, dtype=np.float32, order="C", copy=False)
+                        weight_id = id(weight_arr)
+                        if weight_id not in weight_array_scaled_ids:
+                            weight_array_scaled_ids.add(weight_id)
+                            np.multiply(weight_arr, tw_value, out=weight_arr, casting="unsafe")
+                        weight2d = weight_arr
+                        if isinstance(entry, dict) and weight_source_base == "alpha_weight2d":
+                            entry["alpha_weight2d"] = weight_arr
+                    weight_source = f"{weight_source_base}*tile_weight"
+                    tile_label = (
+                        entry.get("tile_id")
+                        or entry.get("path")
+                        or f"tile_{idx_entry}"
+                    )
+                    if tile_label not in tile_weight_log_ids:
+                        logger.info(
+                            "[Phase5] tile_weight applied: tile=%s tw=%.3f weights_source=%s",
+                            tile_label,
+                            tw_value,
+                            weight_source,
+                        )
+                        tile_weight_log_ids.add(str(tile_label))
                 input_weights_list.append(weight2d)
                 if (
                     not weight_debug_logged
                     and logger.isEnabledFor(logging.DEBUG)
                     and isinstance(weight2d, np.ndarray)
                 ):
                     try:
                         weight_min = float(np.nanmin(weight2d)) if weight2d.size else 0.0
                         weight_max = float(np.nanmax(weight2d)) if weight2d.size else 0.0
                         zero_frac = float(np.mean(weight2d <= 0.0)) if weight2d.size else 0.0
                         logger.debug(
                             "[Phase5] input_weights sample: channel=%d source=%s shape=%s min=%.4f max=%.4f zero_frac=%.4f",
                             ch,
                             weight_source,
                             weight2d.shape,
                             weight_min,
                             weight_max,
                             zero_frac,
                         )
                         weight_debug_logged = True
                     except Exception:
                         pass
             weights_for_entries = None
             if tile_weighting_applied:
                 weights_for_entries = [
                     float(entry.get("tile_weight", 1.0)) if isinstance(entry, dict) else 1.0
                     for entry in valid_entries
                 ]
 
             reproj_call_kwargs = dict(reproj_kwargs)
             reproj_call_kwargs["input_weights"] = input_weights_list
             if use_gpu:
                 for unsupported_kw in ("intertile_global_recenter",):
                     if unsupported_kw in reproj_call_kwargs:
                         reproj_call_kwargs.pop(unsupported_kw, None)
                         logger.debug(
                             "[GPU Reproject] Ignoring unsupported kwarg: %s",
                             unsupported_kw,
                         )
 
             def _invoke_reproject(local_kwargs: dict):
                 invoke_kwargs = dict(local_kwargs)
-                if tile_weighting_applied and weights_for_entries is not None:
+                if (
+                    tile_weighting_applied
+                    and weights_for_entries is not None
+                    and not weights_embedded_with_tile
+                ):
                     invoke_kwargs["tile_weights"] = weights_for_entries
-                return reproject_and_coadd_wrapper(
+                return zemosaic_utils.reproject_and_coadd_wrapper(
                     data_list=data_list,
                     wcs_list=wcs_list,
                     shape_out=final_output_shape_hw,
                     output_projection=output_header,
                     use_gpu=use_gpu,
                     cpu_func=reproject_and_coadd,
                     reproject_function=reproject_interp,
                     combine_function="mean",
                     progress_callback=_pcb,
                     **invoke_kwargs,
                 )
 
             try:
                 chan_mosaic, chan_cov = _invoke_reproject(reproj_call_kwargs)
             except TypeError as gpu_kw_err:
                 if use_gpu:
                     logger.warning(
                         "[GPU Reproject] Unexpected kwargs triggered TypeError: %s",
                         gpu_kw_err,
                     )
                     retry_kwargs = reproj_call_kwargs.copy()
                     removed_after_error: list[str] = []
                     err_msg = str(gpu_kw_err)
                     for key in list(retry_kwargs.keys()):
                         if f"'{key}'" in err_msg:
