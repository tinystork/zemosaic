diff --git a/zemosaic_utils.py b/zemosaic_utils.py
index 94d9e70ce98332fecfae8d06a05d45242628a57e..9b9258112e5d9072eb86567f3c62c41dc3b7e67f 100644
--- a/zemosaic_utils.py
+++ b/zemosaic_utils.py
@@ -32,50 +32,51 @@
 ║                                                                                   ║
 ║ Description:                                                                      ║
 ║   This program was forged under the sacred light of pixels and                    ║
 ║   caffeine, with the noble intent of turning clouds of photons into               ║
 ║   astronomical art. If you use it, please consider saying “thanks,”               ║
 ║   gazing at the stars, or crediting Tinystork and J.A.R.V.I.S. —                  ║
 ║   developer karma depends on it.                                                  ║
 ║                                                                                   ║
 ║ Disclaimer:                                                                       ║
 ║   No AIs or butter knives were harmed in the making of this code.                 ║
 ╚═══════════════════════════════════════════════════════════════════════════════════╝
 """
 
 
 # --- Standard Library Imports ---
 import os
 import math
 import copy
 import json
 import logging
 import re
 import time
 import sys
 import platform
 import tempfile
+from concurrent.futures import ThreadPoolExecutor, as_completed
 from functools import lru_cache
 from contextlib import nullcontext
 from pathlib import Path
 from typing import Any, Callable, Iterable, Optional, Sequence
 import numpy as np
 # L'import de astropy.io.fits est géré ci-dessous pour définir le flag
 import cv2
 
 import warnings
 import traceback
 import gc
 import importlib.util
 
 # --- Optional Astropy WCS import (lightweight, guarded) ----------------------
 ASTROPY_WCS_AVAILABLE_IN_UTILS = False
 AstropyWCS = None
 proj_plane_pixel_scales = None
 try:  # pragma: no cover - optional dependency path
     from astropy.wcs import WCS as AstropyWCS  # type: ignore
     from astropy.wcs.utils import proj_plane_pixel_scales  # type: ignore
 
     ASTROPY_WCS_AVAILABLE_IN_UTILS = True
 except Exception:
     AstropyWCS = None
     proj_plane_pixel_scales = None
@@ -2062,50 +2063,51 @@ def solve_global_affine(num_tiles: int, pair_entries, anchor_index: int = 0):
     offsets = sol[num_tiles:]
     result = {}
     for idx in range(num_tiles):
         g = float(gains[idx])
         o = float(offsets[idx])
         if not np.isfinite(g) or abs(g) < 1e-6:
             g = 1.0
         if not np.isfinite(o):
             o = 0.0
         result[idx] = (g, o)
     return result
 
 
 def compute_intertile_affine_calibration(
     tile_data_with_wcs,
     final_output_wcs,
     final_output_shape_hw,
     preview_size: int = 512,
     min_overlap_fraction: float = 0.05,
     sky_percentile: tuple[float, float] | list[float] = (30.0, 70.0),
     robust_clip_sigma: float = 2.5,
     use_auto_intertile: bool = False,
     logger=None,
     progress_callback=None,
     tile_weights=None,
+    cpu_workers: int | None = None,
 ):
     """Calcule des corrections affine (gain/offset) inter-tuiles avant reprojection.
 
     ``tile_data_with_wcs`` peut contenir des tuples ``(data, wcs)`` ou
     ``(data, wcs, mask2d)`` pour injecter un masque (0..1) optionnel sur la zone
     d'overlap.
     """
 
     if tile_data_with_wcs is None or len(tile_data_with_wcs) < 2:
         return {}
     if reproject_interp is None or not ASTROPY_AVAILABLE_IN_UTILS:
         return {}
     try:
         header_full = final_output_wcs.to_header()
     except Exception:
         return {}
 
     parsed_entries: list[tuple[np.ndarray, Any, np.ndarray | None]] = []
     for entry in tile_data_with_wcs:
         if not isinstance(entry, (list, tuple)) or len(entry) < 2:
             continue
         data = entry[0]
         wcs_obj = entry[1]
         mask = entry[2] if len(entry) >= 3 else None
         parsed_entries.append((data, wcs_obj, mask))
@@ -2141,50 +2143,57 @@ def compute_intertile_affine_calibration(
             mask_tiles.append(None)
             continue
         luminance = _extract_luminance_plane(arr)
         luminance_tiles.append(luminance)
         shapes_hw.append((luminance.shape[0], luminance.shape[1]))
         mask_arr = None
         if mask is not None:
             try:
                 mask_arr = np.asarray(mask, dtype=np.float32)
                 if mask_arr.ndim == 3:
                     mask_arr = mask_arr[..., 0]
                 if mask_arr.shape != luminance.shape[:2]:
                     mask_arr = None
             except Exception:
                 mask_arr = None
         mask_tiles.append(mask_arr)
 
     num_tiles = len(parsed_entries)
 
     try:
         preview_size = int(preview_size)
     except Exception:
         preview_size = 512
     preview_size = max(128, preview_size)
 
+    try:
+        cpu_workers = int(cpu_workers) if cpu_workers is not None else None
+    except Exception:
+        cpu_workers = None
+    if cpu_workers is not None and cpu_workers < 1:
+        cpu_workers = 1
+
     try:
         min_overlap_fraction = float(min_overlap_fraction)
     except Exception:
         min_overlap_fraction = 0.05
     if not math.isfinite(min_overlap_fraction):
         min_overlap_fraction = 0.05
     if min_overlap_fraction < 0:
         min_overlap_fraction = 0.0
 
     def _log_intertile(message: str, level: str = "INFO") -> None:
         prefixed = message if message.startswith("[Intertile]") else f"[Intertile] {message}"
         level_upper = str(level).upper()
         if logger is not None:
             try:
                 if level_upper in {"WARN", "WARNING"}:
                     logger.warning(prefixed)
                 elif level_upper in {"ERROR", "CRITICAL"}:
                     logger.error(prefixed)
                 elif level_upper in {"DEBUG", "DEBUG_DETAIL"}:
                     logger.debug(prefixed)
                 else:
                     logger.info(prefixed)
             except Exception:
                 pass
         if progress_callback:
@@ -2352,181 +2361,223 @@ def compute_intertile_affine_calibration(
             weights_array = None
         if weights_array is not None and len(weights_array) != num_tiles:
             _log_intertile(
                 f"tile_weights ignored: expected {num_tiles}, got {len(weights_array)}",
                 level="WARN",
             )
             weights_array = None
         if weights_array is not None:
             with np.errstate(invalid="ignore"):
                 weights_array = np.where(np.isfinite(weights_array) & (weights_array > 0.0), weights_array, 1.0)
             try:
                 positive = weights_array[weights_array > 0.0]
                 median_ref = float(np.median(positive)) if positive.size else 1.0
             except Exception:
                 median_ref = 1.0
             if not math.isfinite(median_ref) or median_ref <= 0.0:
                 median_ref = 1.0
             with np.errstate(invalid="ignore", divide="ignore"):
                 normed = weights_array / median_ref
                 scores = np.sqrt(normed)
             if scores is not None:
                 scores = np.where(np.isfinite(scores) & (scores > 0.0), scores, 1.0)
             weight_scores = scores
             weights_for_anchor = weights_array
 
-    for idx, overlap in enumerate(overlaps, 1):
-        i = overlap["i"]
-        j = overlap["j"]
-        bbox = overlap["bbox"]
-        weight = float(overlap.get("weight", 1.0))
-        if luminance_tiles[i] is None or luminance_tiles[j] is None:
-            continue
-        x0, x1, y0, y1 = bbox
-        sub_w = max(1, x1 - x0)
-        sub_h = max(1, y1 - y0)
-        header = header_full.copy()
-        header["NAXIS1"] = sub_w
-        header["NAXIS2"] = sub_h
-        if "CRPIX1" in header:
-            header["CRPIX1"] = float(header["CRPIX1"]) - x0
-        if "CRPIX2" in header:
-            header["CRPIX2"] = float(header["CRPIX2"]) - y0
+    preview_size = max(128, int(preview_size))
+
+    def _mask_valid_pixels(mask_arr: np.ndarray | None) -> np.ndarray | None:
+        if mask_arr is None:
+            return None
+        mask_arr = np.asarray(mask_arr, dtype=np.float32)
+        if mask_arr.size == 0:
+            return None
+        finite_mask = np.isfinite(mask_arr)
         try:
-            target_wcs = _WCS(header)
+            max_val = float(np.nanmax(mask_arr))
         except Exception:
-            continue
+            max_val = 0.0
+        threshold = 0.5 if max_val > 0.5 else 0.0
+        return finite_mask & (mask_arr > threshold)
+
+    def _process_overlap_pair(idx_overlap: int, overlap_entry: dict) -> tuple[list[tuple[int, int, float, float, float]] | None, tuple[int, int, float] | None]:
         try:
-            reproj_i, _ = reproject_interp(
-                (luminance_tiles[i], wcs_list[i]), target_wcs, shape_out=(sub_h, sub_w)
-            )
-            reproj_j, _ = reproject_interp(
-                (luminance_tiles[j], wcs_list[j]), target_wcs, shape_out=(sub_h, sub_w)
-            )
-        except Exception:
-            continue
-        if reproj_i is None or reproj_j is None:
-            continue
-        arr_i = np.asarray(reproj_i, dtype=np.float32)
-        arr_j = np.asarray(reproj_j, dtype=np.float32)
-        mask_i_reproj = None
-        mask_j_reproj = None
-        if mask_tiles[i] is not None:
+            i = overlap_entry["i"]
+            j = overlap_entry["j"]
+            bbox = overlap_entry["bbox"]
+            weight = float(overlap_entry.get("weight", 1.0))
+            if luminance_tiles[i] is None or luminance_tiles[j] is None:
+                return None, None
+            x0, x1, y0, y1 = bbox
+            sub_w = max(1, x1 - x0)
+            sub_h = max(1, y1 - y0)
+            header = header_full.copy()
+            header["NAXIS1"] = sub_w
+            header["NAXIS2"] = sub_h
+            if "CRPIX1" in header:
+                header["CRPIX1"] = float(header["CRPIX1"]) - x0
+            if "CRPIX2" in header:
+                header["CRPIX2"] = float(header["CRPIX2"]) - y0
             try:
-                mask_i_reproj, _ = reproject_interp(
-                    (mask_tiles[i], wcs_list[i]), target_wcs, shape_out=(sub_h, sub_w)
-                )
+                target_wcs = _WCS(header)
             except Exception:
-                mask_i_reproj = None
-        if mask_tiles[j] is not None:
+                return None, None
             try:
-                mask_j_reproj, _ = reproject_interp(
-                    (mask_tiles[j], wcs_list[j]), target_wcs, shape_out=(sub_h, sub_w)
+                reproj_i, _ = reproject_interp(
+                    (luminance_tiles[i], wcs_list[i]), target_wcs, shape_out=(sub_h, sub_w)
+                )
+                reproj_j, _ = reproject_interp(
+                    (luminance_tiles[j], wcs_list[j]), target_wcs, shape_out=(sub_h, sub_w)
                 )
             except Exception:
-                mask_j_reproj = None
-        if arr_i.size == 0 or arr_j.size == 0:
-            continue
-        max_dim = max(arr_i.shape[0], arr_i.shape[1])
-        if max_dim > preview_size:
-            scale = preview_size / max_dim
-            new_w = max(8, int(round(arr_i.shape[1] * scale)))
-            new_h = max(8, int(round(arr_i.shape[0] * scale)))
-            arr_i = cv2.resize(arr_i, (new_w, new_h), interpolation=cv2.INTER_AREA)
-            arr_j = cv2.resize(arr_j, (new_w, new_h), interpolation=cv2.INTER_AREA)
-            if mask_i_reproj is not None:
-                mask_i_reproj = cv2.resize(mask_i_reproj, (new_w, new_h), interpolation=cv2.INTER_AREA)
-            if mask_j_reproj is not None:
-                mask_j_reproj = cv2.resize(mask_j_reproj, (new_w, new_h), interpolation=cv2.INTER_AREA)
-
-        def _mask_valid_pixels(mask_arr: np.ndarray | None) -> np.ndarray | None:
-            if mask_arr is None:
-                return None
-            mask_arr = np.asarray(mask_arr, dtype=np.float32)
-            if mask_arr.size == 0:
-                return None
-            finite_mask = np.isfinite(mask_arr)
+                return None, None
+            if reproj_i is None or reproj_j is None:
+                return None, None
+            arr_i = np.asarray(reproj_i, dtype=np.float32)
+            arr_j = np.asarray(reproj_j, dtype=np.float32)
+            mask_i_reproj = None
+            mask_j_reproj = None
+            if mask_tiles[i] is not None:
+                try:
+                    mask_i_reproj, _ = reproject_interp(
+                        (mask_tiles[i], wcs_list[i]), target_wcs, shape_out=(sub_h, sub_w)
+                    )
+                except Exception:
+                    mask_i_reproj = None
+            if mask_tiles[j] is not None:
+                try:
+                    mask_j_reproj, _ = reproject_interp(
+                        (mask_tiles[j], wcs_list[j]), target_wcs, shape_out=(sub_h, sub_w)
+                    )
+                except Exception:
+                    mask_j_reproj = None
+            if arr_i.size == 0 or arr_j.size == 0:
+                return None, None
+            max_dim = max(arr_i.shape[0], arr_i.shape[1])
+            if max_dim > preview_size:
+                scale = preview_size / max_dim
+                new_w = max(8, int(round(arr_i.shape[1] * scale)))
+                new_h = max(8, int(round(arr_i.shape[0] * scale)))
+                arr_i = cv2.resize(arr_i, (new_w, new_h), interpolation=cv2.INTER_AREA)
+                arr_j = cv2.resize(arr_j, (new_w, new_h), interpolation=cv2.INTER_AREA)
+                if mask_i_reproj is not None:
+                    mask_i_reproj = cv2.resize(mask_i_reproj, (new_w, new_h), interpolation=cv2.INTER_AREA)
+                if mask_j_reproj is not None:
+                    mask_j_reproj = cv2.resize(mask_j_reproj, (new_w, new_h), interpolation=cv2.INTER_AREA)
+
+            valid = np.isfinite(arr_i) & np.isfinite(arr_j)
+            mask_i_valid = _mask_valid_pixels(mask_i_reproj)
+            mask_j_valid = _mask_valid_pixels(mask_j_reproj)
+            if mask_i_valid is not None:
+                valid &= mask_i_valid
+            if mask_j_valid is not None:
+                valid &= mask_j_valid
+            if not np.any(valid):
+                return None, None
+            sample_i = arr_i[valid]
+            sample_j = arr_j[valid]
+            if sample_i.size < 64:
+                return None, None
+            sky_proxy = 0.5 * (sample_i + sample_j)
             try:
-                max_val = float(np.nanmax(mask_arr))
+                p_low = np.percentile(sky_proxy, sky_low)
+                p_high = np.percentile(sky_proxy, sky_high)
             except Exception:
-                max_val = 0.0
-            threshold = 0.5 if max_val > 0.5 else 0.0
-            return finite_mask & (mask_arr > threshold)
-
-        valid = np.isfinite(arr_i) & np.isfinite(arr_j)
-        mask_i_valid = _mask_valid_pixels(mask_i_reproj)
-        mask_j_valid = _mask_valid_pixels(mask_j_reproj)
-        if mask_i_valid is not None:
-            valid &= mask_i_valid
-        if mask_j_valid is not None:
-            valid &= mask_j_valid
-        if not np.any(valid):
-            continue
-        sample_i = arr_i[valid]
-        sample_j = arr_j[valid]
-        if sample_i.size < 64:
-            continue
-        sky_proxy = 0.5 * (sample_i + sample_j)
-        try:
-            p_low = np.percentile(sky_proxy, sky_low)
-            p_high = np.percentile(sky_proxy, sky_high)
+                p_low = np.nanmin(sky_proxy)
+                p_high = np.nanmax(sky_proxy)
+            if not np.isfinite(p_low) or not np.isfinite(p_high):
+                return None, None
+            if p_high <= p_low:
+                p_low = np.nanmin(sky_proxy)
+                p_high = np.nanmax(sky_proxy)
+            mask = (sky_proxy >= p_low) & (sky_proxy <= p_high)
+            if mask.sum() < 32:
+                mask = np.ones_like(sky_proxy, dtype=bool)
+            x_samples = sample_i[mask]
+            y_samples = sample_j[mask]
+            fit = robust_affine_fit(x_samples, y_samples, clip_sigma=robust_clip_sigma)
+            if fit is None:
+                return None, None
+            a_ij, b_ij = fit
+            # Preserve legacy duplicate append behavior.
+            pairs_local = [(i, j, a_ij, b_ij, weight), (i, j, a_ij, b_ij, weight)]
+            return pairs_local, (i, j, weight)
         except Exception:
-            p_low = np.nanmin(sky_proxy)
-            p_high = np.nanmax(sky_proxy)
-        if not np.isfinite(p_low) or not np.isfinite(p_high):
-            continue
-        if p_high <= p_low:
-            p_low = np.nanmin(sky_proxy)
-            p_high = np.nanmax(sky_proxy)
-        mask = (sky_proxy >= p_low) & (sky_proxy <= p_high)
-        if mask.sum() < 32:
-            mask = np.ones_like(sky_proxy, dtype=bool)
-        x_samples = sample_i[mask]
-        y_samples = sample_j[mask]
-        fit = robust_affine_fit(x_samples, y_samples, clip_sigma=robust_clip_sigma)
-        if fit is None:
-            continue
-        a_ij, b_ij = fit
-        pair_entries.append((i, j, a_ij, b_ij, weight))
-
-        a_ij, b_ij = fit
-        pair_entries.append((i, j, a_ij, b_ij, weight))
-        connectivity[i] += weight
-        connectivity[j] += weight
-
-        # [ETA] Tick fin de traitement de la paire idx
-        if progress_callback:
-            try:
-                progress_callback("phase5_intertile_pairs", int(idx), int(len(overlaps)))
-            except Exception:
-                pass
+            return None, None
 
-        if progress_callback and idx % 5 == 0:
-            try:
-                progress_callback("phase5_intertile", idx, len(overlaps))
-            except Exception:
-                pass
+    total_pairs = len(overlaps)
+    use_parallel = cpu_workers is not None and cpu_workers > 1 and total_pairs >= 4
+    if use_parallel:
+        workers = min(cpu_workers, 16) if cpu_workers is not None else 1
+        workers = max(1, workers)
+        _log_intertile(
+            f"Parallel: threadpool workers={workers} pairs={total_pairs} preview={preview_size}",
+            level="INFO",
+        )
+        with ThreadPoolExecutor(max_workers=workers) as executor:
+            future_map = {
+                executor.submit(_process_overlap_pair, idx, overlap): idx
+                for idx, overlap in enumerate(overlaps, 1)
+            }
+            for future in as_completed(future_map):
+                idx = future_map[future]
+                pairs_local, connectivity_entry = future.result()
+                if pairs_local:
+                    pair_entries.extend(pairs_local)
+                if connectivity_entry:
+                    i_conn, j_conn, w_conn = connectivity_entry
+                    connectivity[i_conn] += w_conn
+                    connectivity[j_conn] += w_conn
+                if progress_callback:
+                    try:
+                        progress_callback("phase5_intertile_pairs", int(idx), int(total_pairs))
+                    except Exception:
+                        pass
+                    if idx % 5 == 0:
+                        try:
+                            progress_callback("phase5_intertile", idx, total_pairs)
+                        except Exception:
+                            pass
+    else:
+        for idx, overlap in enumerate(overlaps, 1):
+            pairs_local, connectivity_entry = _process_overlap_pair(idx, overlap)
+            if pairs_local:
+                pair_entries.extend(pairs_local)
+            if connectivity_entry:
+                i_conn, j_conn, w_conn = connectivity_entry
+                connectivity[i_conn] += w_conn
+                connectivity[j_conn] += w_conn
+            if progress_callback:
+                try:
+                    progress_callback("phase5_intertile_pairs", int(idx), int(total_pairs))
+                except Exception:
+                    pass
+                if idx % 5 == 0:
+                    try:
+                        progress_callback("phase5_intertile", idx, total_pairs)
+                    except Exception:
+                        pass
 
     if not pair_entries:
         return {}
 
     if weight_scores is None:
         anchor = int(np.argmax(connectivity)) if np.any(connectivity > 0) else 0
     else:
         if np.any(connectivity > 0):
             score = connectivity * weight_scores
             anchor = int(np.argmax(score))
             selected_score = float(score[anchor])
         else:
             score = weight_scores
             anchor = int(np.argmax(weight_scores))
             selected_score = float(weight_scores[anchor])
         selected_connectivity = float(connectivity[anchor])
         selected_weight = float(weights_for_anchor[anchor]) if weights_for_anchor is not None else 1.0
         try:
             _log_intertile(
                 f"Anchor selection biased: anchor={anchor} connectivity={selected_connectivity:.4f} weight={selected_weight:.4f} score={selected_score:.4f}",
                 level="INFO",
             )
         except Exception:
             pass
 
diff --git a/zemosaic_worker.py b/zemosaic_worker.py
index 6cbf4c3310e814bf1a70e8a33a96504cb14cac61..2a39fddbc262cb3e9c758df7c46470d706e9ce9c 100644
--- a/zemosaic_worker.py
+++ b/zemosaic_worker.py
@@ -6233,71 +6233,79 @@ def _select_quality_anchor(
         "center_anchor_selected",
         lvl="INFO",
         callback=progress_callback,
         tile=int(best_entry["tile_id"]),
         dist_deg=best_entry.get("distance"),
         score=best_score,
     )
 
     return int(best_entry["tile_id"])
 
 
 def _compute_intertile_affine_corrections_from_sources(
     sources: list[_TileAffineSource],
     final_output_wcs,
     final_output_shape_hw: tuple[int, int],
     preview_size: int,
     min_overlap_fraction: float,
     sky_percentile: tuple[float, float] | list[float],
     robust_clip_sigma: float,
     use_auto_intertile: bool,
     logger_obj=None,
     progress_callback: Callable | None = None,
     intertile_global_recenter: bool = False,
     intertile_recenter_clip: tuple[float, float] | list[float] | None = None,
     tile_weights: list[float] | None = None,
+    cpu_workers: int | None = None,
 ) -> tuple[list[tuple[float, float]] | None, bool, str, str | None]:
     """Common implementation for intertile gain/offset computation.
 
     Returns
     -------
     (list[(gain, offset)] | None, bool, str, str | None)
         Sanitized affine list (or ``None``), flag indicating whether non-trivial
         corrections were detected, status string (``\"ok\"``, ``\"skipped\"``,
         ``\"preview_failed\"``, ``\"compute_failed\"``) and optional error message.
     """
 
     total_tiles = len(sources)
     if total_tiles < 2:
         return None, False, "skipped", None
 
     if not (
         ZEMOSAIC_UTILS_AVAILABLE
         and hasattr(zemosaic_utils, "compute_intertile_affine_calibration")
     ):
         return None, False, "skipped", None
 
+    try:
+        cpu_workers = int(cpu_workers) if cpu_workers is not None else None
+    except Exception:
+        cpu_workers = None
+    if cpu_workers is not None and cpu_workers < 1:
+        cpu_workers = 1
+
     tile_pairs: list[tuple[np.ndarray, Any] | tuple[np.ndarray, Any, np.ndarray]] = []
     preview_arrays: list[np.ndarray | None] = []
 
     for idx, src in enumerate(sources, 1):
         try:
             tile_arr: np.ndarray
             mask2d_float: np.ndarray | None = None
             alpha_mask_arr: np.ndarray | None = None
             label = _safe_basename(src.path)
             if src.data is not None:
                 tile_arr = _ensure_hwc_master_tile(src.data, label)
             else:
                 if not src.path:
                     raise ValueError("Tile data missing and no path provided.")
                 with fits.open(src.path, memmap=False) as hdul:
                     tile_arr = _ensure_hwc_master_tile(hdul[0].data, label)
                     if "ALPHA" in hdul and hdul["ALPHA"].data is not None:
                         try:
                             alpha_mask_arr = np.asarray(hdul["ALPHA"].data)
                         except Exception:
                             alpha_mask_arr = None
             tile_arr = np.asarray(tile_arr, dtype=np.float32, order="C")
             mask_source = getattr(src, "mask", None)
             if mask_source is not None:
                 try:
@@ -6412,50 +6420,51 @@ def _compute_intertile_affine_corrections_from_sources(
                 except Exception:
                     pass
         except Exception:
             pass
         # Relais vers le callback GUI d'origine pour l'affichage + ETA fine (via on_worker_progress)
         if progress_callback:
             try:
                 progress_callback(message_or_stage, current, level, **kwargs)
             except Exception:
                 pass
 
     try:
         corrections = zemosaic_utils.compute_intertile_affine_calibration(
 
             tile_pairs,
             final_output_wcs,
             final_output_shape_hw,
             preview_size=preview_size,
             min_overlap_fraction=min_overlap_fraction,
             sky_percentile=sky_percentile,
             robust_clip_sigma=robust_clip_sigma,
             use_auto_intertile=use_auto_intertile,
             logger=logger_obj,
             progress_callback=_intertile_progress_bridge,
             tile_weights=tile_weights,
+            cpu_workers=cpu_workers,
         )
     except Exception as exc:
         if logger_obj:
             logger_obj.warning(
                 "Intertile photometric calibration failed: %s",
                 exc,
             )
             logger_obj.debug("Traceback (intertile failure):", exc_info=True)
         return None, False, "compute_failed", str(exc)
     finally:
         tile_pairs.clear()
 
     sanitized, nontrivial = _sanitize_affine_corrections(corrections, total_tiles)
 
     if sanitized and intertile_global_recenter and preview_arrays:
         clip_cfg = intertile_recenter_clip if isinstance(intertile_recenter_clip, (list, tuple)) else None
         if not clip_cfg or len(clip_cfg) < 2:
             clip_cfg = (0.85, 1.18)
         try:
             clip_low = float(clip_cfg[0])
         except Exception:
             clip_low = 0.85
         try:
             clip_high = float(clip_cfg[1])
         except Exception:
@@ -12468,50 +12477,55 @@ def assemble_final_mosaic_incremental(
         affine_start = time.monotonic()
         pcb_asm(
             "run_info_incremental_affine_start",
             prog=None,
             lvl="INFO",
             num_tiles=total_tiles,
         )
         tile_sources = [
             _TileAffineSource(path=tile_path, wcs=tile_wcs)
             for tile_path, tile_wcs in master_tile_fits_with_wcs_list
         ]
         pending_affine_list, nontrivial_detected, affine_status, affine_error = (
             _compute_intertile_affine_corrections_from_sources(
                 sources=tile_sources,
                 final_output_wcs=final_output_wcs,
                 final_output_shape_hw=final_output_shape_hw,
                 preview_size=int(intertile_preview_size),
                 min_overlap_fraction=float(intertile_overlap_min),
                 sky_percentile=intertile_sky_percentile,
                 robust_clip_sigma=float(intertile_robust_clip_sigma),
                 use_auto_intertile=use_auto_intertile,
                 logger_obj=logger,
                 progress_callback=progress_callback,
                 intertile_global_recenter=bool(intertile_global_recenter),
                 intertile_recenter_clip=intertile_recenter_clip,
+                cpu_workers=(
+                    int(processing_threads)
+                    if processing_threads and int(processing_threads) > 0
+                    else min(os.cpu_count() or 1, 8)
+                ),
             )
         )
         if affine_status == "preview_failed":
             pcb_asm(
                 "assemble_warn_intertile_photometric_failed",
                 prog=None,
                 lvl="WARN",
                 error="preview_failed",
             )
             pending_affine_list = None
             nontrivial_detected = False
         elif affine_status == "compute_failed":
             pcb_asm(
                 "assemble_warn_intertile_photometric_failed",
                 prog=None,
                 lvl="WARN",
                 error=str(affine_error),
             )
             pending_affine_list = None
             nontrivial_detected = False
         affine_elapsed = time.monotonic() - affine_start
         if nontrivial_detected:
             try:
                 pcb_asm(
                     "assemble_info_intertile_photometric_applied",
@@ -13720,50 +13734,55 @@ def assemble_final_mosaic_reproject_coadd(
             tile_weights_for_sources.append(weight_val)
             tile_sources.append(
                 _TileAffineSource(
                     path=entry.get("path"),
                     wcs=entry.get("wcs"),
                     data=entry.get("data"),
                     mask=mask,
                 )
             )
 
         pending_affine_list, nontrivial_affine, affine_status, affine_error = (
             _compute_intertile_affine_corrections_from_sources(
                 sources=tile_sources,
                 final_output_wcs=final_output_wcs,
                 final_output_shape_hw=final_output_shape_hw,
                 preview_size=int(intertile_preview_size),
                 min_overlap_fraction=float(intertile_overlap_min),
                 sky_percentile=intertile_sky_percentile,
                 robust_clip_sigma=float(intertile_robust_clip_sigma),
                 use_auto_intertile=use_auto_intertile,
                 logger_obj=logger,
                 progress_callback=progress_callback,
                 intertile_global_recenter=bool(intertile_global_recenter),
                 intertile_recenter_clip=intertile_recenter_clip,
                 tile_weights=tile_weights_for_sources,
+                cpu_workers=(
+                    int(assembly_process_workers)
+                    if assembly_process_workers and int(assembly_process_workers) > 0
+                    else min(os.cpu_count() or 1, 8)
+                ),
             )
         )
 
         if affine_status == "preview_failed":
             _pcb(
                 "assemble_warn_intertile_photometric_failed",
                 prog=None,
                 lvl="WARN",
                 error="preview_failed",
             )
             pending_affine_list = None
             nontrivial_affine = False
         elif affine_status == "compute_failed":
             _pcb(
                 "assemble_warn_intertile_photometric_failed",
                 prog=None,
                 lvl="WARN",
                 error=str(affine_error),
             )
             pending_affine_list = None
             nontrivial_affine = False
 
     total_tiles_prepared = len(effective_tiles)
     pending_affine_list, anchor_shift_applied = _compose_global_anchor_shift(
         pending_affine_list,
