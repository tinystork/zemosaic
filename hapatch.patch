diff --git a/zemosaic_worker.py b/zemosaic_worker.py
index dd4fb9afb979f6ae40dbf8ab83fbe32d59fbf454..f8d1c20e8eb86dc9372f9d016f16891325341144 100644
--- a/zemosaic_worker.py
+++ b/zemosaic_worker.py
@@ -14868,76 +14868,157 @@ def run_second_pass_coverage_renorm(
     if chunk_hint is None and use_gpu and plan_chunk_cpu_hint:
         chunk_hint = plan_chunk_cpu_hint
     if row_hint:
         reproj_kwargs["rows_per_chunk"] = int(max(1, row_hint))
     if chunk_hint:
         reproj_kwargs["max_chunk_bytes"] = int(max(1, chunk_hint))
     if logger:
         try:
             logger.info(
                 "[TwoPass] Reprojection plan: gpu=%s cpu_workers=%s rows(cpu/gpu)=%s/%s chunk_mb(cpu/gpu)=%.2f/%.2f memmap=%s",
                 use_gpu,
                 cpu_workers_hint or "-",
                 plan_rows_cpu_hint or 0,
                 plan_rows_gpu_hint or 0,
                 (plan_chunk_cpu_hint or 0) / (1024 ** 2),
                 (plan_chunk_gpu_hint or 0) / (1024 ** 2),
                 bool(use_memmap_flag),
             )
         except Exception:
             pass
 
     n_channels = corrected_tiles[0].shape[-1] if corrected_tiles[0].ndim == 3 else 1
     mosaic_channels: list[np.ndarray | None] = [None] * n_channels
     coverage_channels: list[np.ndarray | None] = [None] * n_channels
     shape_out_hw = tuple(map(int, shape_out))
+    weights_2d_list: list[np.ndarray | None] | None = None
+    if tiles_coverage is not None:
+        try:
+            weights_tmp: list[np.ndarray | None] = []
+            for cov_arr, tile_arr in zip(tiles_coverage, corrected_tiles):
+                if cov_arr is None:
+                    weights_tmp.append(None)
+                    continue
+                cov_np = np.asarray(cov_arr, dtype=np.float32)
+                if cov_np.ndim == 3:
+                    cov2d = cov_np[..., 0]
+                else:
+                    cov2d = cov_np
+                tile_h, tile_w = tile_arr.shape[0], tile_arr.shape[1]
+                if cov2d.shape != (tile_h, tile_w):
+                    if logger:
+                        logger.debug(
+                            "[TwoPass] tiles_coverage shape mismatch for tile: cov=%s tile=%s → ignoring coverage for this tile",
+                            cov2d.shape,
+                            (tile_h, tile_w),
+                        )
+                    weights_tmp.append(None)
+                    continue
+                weight2d = (cov2d > 0.0).astype(np.float32)
+                weights_tmp.append(weight2d)
+            if any(w is not None for w in weights_tmp):
+                weights_2d_list = weights_tmp
+        except Exception:
+            weights_2d_list = None
+            if logger and logger.isEnabledFor(logging.DEBUG):
+                logger.debug("[TwoPass] failed to prepare tiles_coverage weights → skip", exc_info=True)
 
     def _process_channel(ch_idx: int, use_gpu_flag: bool) -> tuple[int, np.ndarray, np.ndarray]:
         if logger:
             logger.debug(
                 "[TwoPass] Reproject channel %d/%d with %d tiles (shape_out=%s, gpu=%s)",
                 ch_idx + 1,
                 n_channels,
                 len(corrected_tiles),
                 shape_out_hw,
                 use_gpu_flag,
             )
         data_list = [tile[..., ch_idx] if tile.ndim == 3 else tile[..., 0] for tile in corrected_tiles]
+        input_weights_list = None
+        if weights_2d_list is not None:
+            try:
+                iw: list[np.ndarray | None] = []
+                for base_w, tile_arr in zip(weights_2d_list, corrected_tiles):
+                    if base_w is None:
+                        iw.append(None)
+                        continue
+                    tile_slice = tile_arr[..., ch_idx] if tile_arr.ndim == 3 else tile_arr[..., 0]
+                    if base_w.shape != tile_slice.shape:
+                        if logger and logger.isEnabledFor(logging.DEBUG):
+                            logger.debug(
+                                "[TwoPass] input_weights shape mismatch for channel %d: w=%s slice=%s → ignoring weight",
+                                ch_idx + 1,
+                                base_w.shape,
+                                tile_slice.shape,
+                            )
+                        iw.append(None)
+                    else:
+                        iw.append(base_w)
+                if any(w is not None for w in iw):
+                    input_weights_list = iw
+            except Exception:
+                input_weights_list = None
+                if logger and logger.isEnabledFor(logging.DEBUG):
+                    logger.debug(
+                        "[TwoPass] failed to prepare input_weights for channel %d → skip weights",
+                        ch_idx + 1,
+                        exc_info=True,
+                    )
 
         def _invoke_reproj(use_gpu_local: bool, local_kwargs: dict[str, Any]):
             return zemosaic_utils.reproject_and_coadd_wrapper(
                 data_list=data_list,
                 wcs_list=tiles_wcs,
                 shape_out=shape_out_hw,
                 use_gpu=use_gpu_local,
                 cpu_func=reproject_and_coadd,
                 **local_kwargs,
             )
 
         local_kwargs = dict(reproj_kwargs)
+        if input_weights_list is not None:
+            local_kwargs["input_weights"] = input_weights_list
         try:
             chan_mosaic, chan_cov = _invoke_reproj(use_gpu_flag, local_kwargs)
+            if logger and logger.isEnabledFor(logging.DEBUG):
+                cov1 = np.asarray(coverage_p1, dtype=np.float32)
+                cov2 = np.asarray(chan_cov, dtype=np.float32)
+                if cov1.shape == cov2.shape:
+                    bad_mask = (cov1 > 0.0) & (cov2 <= 0.0)
+                    n_bad = int(np.count_nonzero(bad_mask))
+                    logger.debug(
+                        "[TwoPass] channel %d coverage mismatch: cov1>0 & cov2==0 → %d pixels",
+                        ch_idx + 1,
+                        n_bad,
+                    )
+                else:
+                    logger.debug(
+                        "[TwoPass] channel %d coverage shape mismatch for debug: cov1=%s cov2=%s",
+                        ch_idx + 1,
+                        cov1.shape,
+                        cov2.shape,
+                    )
         except wcs_module.NoConvergence as conv_exc:
             if logger:
                 logger.warning(
                     "[TwoPass] WCS convergence failed on channel %d%s: %s",
                     ch_idx,
                     " (GPU)" if use_gpu_flag else "",
                     conv_exc,
                     exc_info=False,
                 )
             if use_gpu_flag:
                 raise
             chan_mosaic = np.full(shape_out_hw, np.nan, dtype=np.float32)
             chan_cov = np.zeros(shape_out_hw, dtype=np.float32)
         except TypeError as type_err:
             if logger:
                 logger.warning("[TwoPass] GPU reprojection TypeError, attempting recovery: %s", type_err)
             chan_mosaic = chan_cov = None
             if use_gpu_flag:
                 retry_kwargs = dict(local_kwargs)
                 removed = []
                 err_msg = str(type_err)
                 for key in list(retry_kwargs.keys()):
                     if f"'{key}'" in err_msg:
                         removed.append(key)
                         retry_kwargs.pop(key, None)
