# zemosaic_worker.py

import os
import shutil
import time
import traceback
import gc
import logging
import inspect  # Pas utilisé directement ici, mais peut être utile pour des introspections futures
import psutil
import tempfile
import glob
import uuid
import multiprocessing
import threading
from typing import Callable
from types import SimpleNamespace

from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, as_completed
# BrokenProcessPool moved under concurrent.futures.process in modern Python
from concurrent.futures.process import BrokenProcessPool


def cluster_seestar_stacks_connected(all_raw_files_with_info: list, stack_threshold_deg: float, progress_callback: callable):
    """Order-invariant clustering of Seestar raws using spherical proximity.

    Builds a proximity graph (edges when separation < threshold) and returns
    connected components. Deterministic across runs when input ordering is
    stable (we sort file paths earlier).
    """
    # Deps imported later in module; they will be available at runtime
    try:
        ok_astropy = ASTROPY_AVAILABLE and (SkyCoord is not None) and (u is not None) and (Angle is not None)
    except NameError:
        ok_astropy = False
    if not ok_astropy:
        _log_and_callback("clusterstacks_error_astropy_unavailable", level="ERROR", callback=progress_callback)
        return []
    if not all_raw_files_with_info:
        _log_and_callback("clusterstacks_warn_no_raw_info", level="WARN", callback=progress_callback)
        return []
    _log_and_callback(
        "clusterstacks_info_start",
        num_files=len(all_raw_files_with_info),
        threshold=stack_threshold_deg,
        level="INFO",
        callback=progress_callback,
    )
    panel_centers_sky = []
    panel_data_for_clustering = []
    for info in all_raw_files_with_info:
        wcs_obj = info.get("wcs")
        if not (wcs_obj and getattr(wcs_obj, "is_celestial", False)):
            continue
        try:
            if getattr(wcs_obj, "pixel_shape", None):
                cx = wcs_obj.pixel_shape[0] / 2.0
                cy = wcs_obj.pixel_shape[1] / 2.0
                center_world = wcs_obj.pixel_to_world(cx, cy)
            elif hasattr(wcs_obj, "wcs") and hasattr(wcs_obj.wcs, "crval"):
                center_world = SkyCoord(
                    ra=float(wcs_obj.wcs.crval[0]) * u.deg,
                    dec=float(wcs_obj.wcs.crval[1]) * u.deg,
                    frame="icrs",
                )
            else:
                continue
            panel_centers_sky.append(center_world)
            panel_data_for_clustering.append(info)
        except Exception:
            continue
    if not panel_centers_sky:
        _log_and_callback("clusterstacks_warn_no_centers", level="WARN", callback=progress_callback)
        return []
    coords = SkyCoord(
        ra=[c.ra for c in panel_centers_sky],
        dec=[c.dec for c in panel_centers_sky],
        frame="icrs",
    )
    max_sep = Angle(float(stack_threshold_deg), unit=u.deg)
    try:
        idx1, idx2, _, _ = coords.search_around_sky(coords, max_sep)
    except Exception:
        idx1, idx2 = np.array([], dtype=int), np.array([], dtype=int)
    n = len(coords)
    parent = list(range(n))
    def find(a):
        while parent[a] != a:
            parent[a] = parent[parent[a]]
            a = parent[a]
        return a
    def union(a, b):
        ra, rb = find(a), find(b)
        if ra != rb:
            parent[rb] = ra
    for a, b in zip(idx1, idx2):
        ia, ib = int(a), int(b)
        if ia == ib:
            continue
        union(ia, ib)
    groups_indices = {}
    for i in range(n):
        r = find(i)
        groups_indices.setdefault(r, []).append(i)
    ordered_roots = sorted(groups_indices.keys(), key=lambda r: min(groups_indices[r]))
    groups = []
    for r in ordered_roots:
        members = groups_indices[r]
        members.sort()
        groups.append([panel_data_for_clustering[i] for i in members])
    _log_and_callback("clusterstacks_info_finished", num_groups=len(groups), level="INFO", callback=progress_callback)
    return groups


# --- Configuration du Logging ---
logger = logging.getLogger("ZeMosaicWorker")
if not logger.handlers:
    logger.setLevel(logging.DEBUG)
    try:
        log_file_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "zemosaic_worker.log")
    except NameError: 
        log_file_path = "zemosaic_worker.log"
    fh = logging.FileHandler(log_file_path, mode='w', encoding='utf-8')
    fh.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(module)s.%(funcName)s:%(lineno)d - %(message)s')
    fh.setFormatter(formatter)
    logger.addHandler(fh)
logger.info("Logging pour ZeMosaicWorker initialisé. Logs écrits dans: %s", log_file_path)

# --- Alignment Warning Tracking ---
# These warnings come from zemosaic_align_stack when an image fails to align.
# We count them here so a summary can be written at the end of a run.
ALIGN_WARNING_SUMMARY = {
    "aligngroup_warn_max_iter_error": "astroalign MaxIterError",
    "aligngroup_warn_shape_mismatch_after_align": "shape mismatch after align",
    "aligngroup_warn_register_returned_none": "astroalign returned None",
    "aligngroup_warn_value_error": "value error during align",
}
ALIGN_WARNING_COUNTS = {key: 0 for key in ALIGN_WARNING_SUMMARY}

# --- Third-Party Library Imports ---
import numpy as np
import zarr
from packaging.version import Version

try:
    from zarr.storage import LRUStoreCache
    if Version(zarr.__version__).major >= 3:
        # In zarr>=3 LRUStoreCache was removed. Use a no-op wrapper
        raise ImportError
except Exception:  # pragma: no cover - fallback for zarr>=3 or missing cache
    class LRUStoreCache:
        """Simple pass-through wrapper used when LRUStoreCache is unavailable."""

        def __init__(self, store, max_size=None):
            self.store = store

        def __getattr__(self, name):
            return getattr(self.store, name)

try:
    # Prefer storage module first (zarr < 3)
    from zarr.storage import DirectoryStore
except Exception:
    try:  # pragma: no cover - zarr >= 3 uses LocalStore
        from zarr.storage import LocalStore as DirectoryStore
    except Exception:
        try:
            from zarr.storage import FsspecStore
            import fsspec

            def DirectoryStore(path):
                return FsspecStore(fsspec.filesystem("file").get_mapper(path))
        except Exception:  # pragma: no cover - ultimate fallback
            DirectoryStore = None

# now LRUStoreCache and DirectoryStore are defined


# --- Astropy (critique) ---
ASTROPY_AVAILABLE = False
WCS, SkyCoord, Angle, fits, u = None, None, None, None, None
try:
    from astropy.io import fits as actual_fits
    from astropy.wcs import WCS as actual_WCS
    from astropy.coordinates import SkyCoord as actual_SkyCoord, Angle as actual_Angle
    from astropy import units as actual_u
    fits, WCS, SkyCoord, Angle, u = actual_fits, actual_WCS, actual_SkyCoord, actual_Angle, actual_u
    ASTROPY_AVAILABLE = True
    logger.info("Bibliothèque Astropy importée.")
except ImportError as e_astro_imp: logger.critical(f"Astropy non trouvée: {e_astro_imp}.")
except Exception as e_astro_other_imp: logger.critical(f"Erreur import Astropy: {e_astro_other_imp}", exc_info=True)

# --- Reproject (critique pour la mosaïque) ---
REPROJECT_AVAILABLE = False
find_optimal_celestial_wcs, reproject_and_coadd, reproject_interp = None, None, None
try:
    from reproject.mosaicking import find_optimal_celestial_wcs as actual_find_optimal_wcs
    from reproject.mosaicking import reproject_and_coadd as actual_reproject_coadd
    from reproject import reproject_interp as actual_reproject_interp
